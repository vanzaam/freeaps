---
description: FreeAPS X SwiftUI Graphics and Charting Best Practices
globs: ["**/*.swift"]
alwaysApply: true
---

# FreeAPS X SwiftUI Graphics and Charting Best Practices

## üöÄ **BEST METHOD: High-Performance SwiftUI Graphics**

**This is the OPTIMAL approach for drawing any charts/graphs in SwiftUI - proven to work flawlessly with zero lag!**

## Core Graphics Architecture

### 1. **Path API - The Secret Weapon**
```swift
Path { path in
    for (i, value) in values.enumerated() {
        let x = CGFloat(i) * stepX
        let y = height - CGFloat(normalized) * (height - 2)
        if i == 0 { 
            path.move(to: CGPoint(x: x, y: y)) 
        } else { 
            path.addLine(to: CGPoint(x: x, y: y)) 
        }
    }
}
.stroke(Color.green, lineWidth: 2)
```
- **GPU Acceleration**: Path compiles to Metal shaders
- **Single Draw Call**: Renders entire graph in one operation
- **Hardware Optimized**: Uses video card for rendering
- **Zero Lag**: Even with thousands of data points

### 2. **GeometryReader - Smart Positioning**
```swift
GeometryReader { geometry in
    let width = geometry.size.width
    let height = geometry.size.height
    let stepX = width / CGFloat(count - 1)
    // All calculations in one place
}
```
- **Auto-Adaptive**: Automatically adjusts to container size
- **Cached Calculations**: Only recalculates when size changes
- **Responsive**: Works on any screen size

### 3. **ZStack + Overlay - Layered Architecture**
```swift
ZStack {
    // Background grid
    Path { /* grid lines */ }
        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
    
    // Main data graph
    Path { /* data line */ }
        .stroke(Color.green, lineWidth: 2)
    
    // Interactive overlay
    Rectangle()
        .fill(Color.clear)
        .contentShape(Rectangle())
        .gesture(/* touch handling */)
    
    // Labels and annotations
    ForEach(/* labels */) { /* label views */ }
}
```
- **Layer Separation**: Each element renders independently
- **Selective Updates**: Only changed layers redraw
- **Performance**: SwiftUI optimizes layer rendering

### 4. **HighPriorityGesture - Instant Response**
```swift
.highPriorityGesture(
    DragGesture(minimumDistance: 0)
        .onChanged { value in
            // Update hover state instantly
            hoverIndex = Int(value.location.x / stepX)
        }
)
```
- **Zero Delay**: minimumDistance: 0 for instant response
- **Priority**: Overrides other gestures
- **Smooth**: Direct access to touch coordinates

### 5. **Computed Properties - Lazy Evaluation**
```swift
let values = data.map { Double($0.value) }
let maxValue = max(values.max() ?? 1, 1)
let stepX = count > 1 ? width / CGFloat(count - 1) : width
let normalized = value / maxValue
```
- **Cached**: Only recalculates when data changes
- **Efficient**: No redundant calculations
- **Memory Safe**: No unnecessary object creation

## Performance Secrets

### Why This Method is SO Fast:
1. **GPU Rendering**: Path uses Metal shaders (video card)
2. **Single Draw Call**: One operation instead of hundreds
3. **Minimal Redraws**: Only changed parts update
4. **Native Performance**: SwiftUI compiles to native code
5. **Hardware Acceleration**: Uses device's graphics processor

### Memory Efficiency:
- **No View Objects**: Path doesn't create individual views
- **Minimal State**: Only essential data in memory
- **Efficient Updates**: Only changed data triggers redraw

## Interactive Features

### Hover/Touch Handling:
```swift
Rectangle()
    .fill(Color.clear)
    .contentShape(Rectangle())
    .highPriorityGesture(
        DragGesture(minimumDistance: 0)
            .onChanged { value in
                let index = Int(value.location.x / stepX)
                if index >= 0 && index < data.count {
                    hoverIndex = index
                }
            }
    )
```

### Tooltip Positioning:
```swift
if let hoverIndex = hoverIndex {
    VStack(alignment: .leading) {
        Text("Time: \(data[hoverIndex].time)")
        Text("Value: \(data[hoverIndex].value)")
    }
    .position(x: 70, y: 30) // Fixed position
    .background(Color.black.opacity(0.8))
    .foregroundColor(.white)
    .cornerRadius(8)
}
```

## Best Practices

### ‚úÖ **DO:**
- Use `Path` for all line graphs
- Use `GeometryReader` for responsive sizing
- Use `ZStack` for layered graphics
- Use `HighPriorityGesture` for touch
- Use computed properties for calculations
- Use `contentShape(Rectangle())` for touch areas

### ‚ùå **DON'T:**
- Create individual views for each data point
- Use `ForEach` for line drawing
- Use `VStack`/`HStack` for positioning
- Use `onTapGesture` for continuous interaction
- Recalculate on every render

## Real-World Examples

### COB Absorption Graph:
- **Data Points**: 180 points (6 hours √ó 2 minutes)
- **Performance**: Zero lag, instant touch response
- **Memory**: Minimal footprint
- **Smoothness**: 60 FPS even on older devices

### Glucose Trend Chart:
- **Data Points**: 288 points (24 hours √ó 5 minutes)
- **Performance**: Instant rendering
- **Interactivity**: Real-time hover feedback
- **Responsiveness**: Works on all screen sizes

## When to Use This Method

### ‚úÖ **Perfect For:**
- Line charts and graphs
- Real-time data visualization
- Interactive dashboards
- Performance-critical displays
- Any chart with >50 data points

### ‚ö†Ô∏è **Consider Alternatives For:**
- Simple static displays (<10 points)
- Pie charts (use `Path` with arcs)
- Bar charts (use `HStack` with rectangles)
- Complex 3D graphics (use SceneKit)

## FreeAPS X Specific Graphics Requirements

### Glucose Charts
- **Real-time Updates**: Smooth updates without lag
- **High-frequency Data**: Handle CGM data every 5 minutes
- **Interactive Tooltips**: Show glucose values on touch
- **Trend Arrows**: Display glucose direction indicators
- **Target Ranges**: Visualize target glucose ranges

### COB Absorption Graphs
- **6-hour Windows**: Display carb absorption over time
- **Smooth Curves**: Use Path API for smooth absorption curves
- **Interactive Points**: Touch to see carb details
- **Color Coding**: Different colors for different carb types

### IOB (Insulin on Board) Charts
- **Insulin Decay**: Show insulin activity over time
- **Multiple Sources**: Basal, bolus, and correction insulin
- **Visual Indicators**: Clear representation of active insulin
- **Time-based Display**: Show insulin activity timeline

## FreeAPS X Performance Requirements
- **Zero Lag**: All charts must render without delay
- **Memory Efficient**: Handle large datasets without memory issues
- **Battery Optimized**: Minimize CPU usage for graphics
- **Smooth Animations**: 60 FPS performance on all devices
- **Responsive Touch**: Instant feedback on user interactions

## Conclusion

**This is the GOLD STANDARD for SwiftUI graphics in FreeAPS X!** 

- **Performance**: GPU-accelerated, zero lag
- **Responsiveness**: Instant touch feedback
- **Scalability**: Handles thousands of points
- **Maintainability**: Clean, readable code
- **Efficiency**: Minimal memory usage
- **FreeAPS X Optimized**: Specifically designed to eliminate iAPS performance issues

**Use this pattern for ALL charts and graphs in FreeAPS X to ensure smooth, lag-free performance!** üöÄ